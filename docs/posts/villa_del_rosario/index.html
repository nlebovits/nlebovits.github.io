<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<link rel="alternate" hreflang="en" href="/posts/villa_del_rosario/index.html" />
<link rel="alternate" hreflang="es" href="/es/posts/villa_del_rosario/index.es.html" />
<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-09-10">

<title>Análisis de datos de incendios en Villa del Rosario | Nissim Lebovits – Nissim Lebovits</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../assets/alps_profile_pic.jpeg" rel="icon" type="image/jpeg">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>
<script src="../../site_libs/clipboard-1.7.1/clipboard.min.js"></script>
<link href="../../site_libs/primer-tooltips-1.4.0/build.css" rel="stylesheet">
<link href="../../site_libs/klippy-0.0.0.9500/css/klippy.min.css" rel="stylesheet">
<script src="../../site_libs/klippy-0.0.0.9500/js/klippy.min.js"></script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Nissim Lebovits</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">My Work</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../assets/2025_06_04_lebovits_full_resume.pdf"> 
<span class="menu-text">Resumé</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://datosaescalahumana.substack.com/s/english"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/nlebovits/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/nlebovits/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#pasos" id="toc-pasos" class="nav-link active" data-scroll-target="#pasos">Pasos</a>
  <ul class="collapse">
  <li><a href="#instalación-de-qgis" id="toc-instalación-de-qgis" class="nav-link" data-scroll-target="#instalación-de-qgis">Instalación de QGIS</a></li>
  <li><a href="#google-earth-engine" id="toc-google-earth-engine" class="nav-link" data-scroll-target="#google-earth-engine">Google Earth Engine</a></li>
  <li><a href="#descargar-los-siguientes-datasets" id="toc-descargar-los-siguientes-datasets" class="nav-link" data-scroll-target="#descargar-los-siguientes-datasets">Descargar los siguientes datasets</a></li>
  <li><a href="#datos-de-incendios-modisviirs-procesados-opción-alternativa" id="toc-datos-de-incendios-modisviirs-procesados-opción-alternativa" class="nav-link" data-scroll-target="#datos-de-incendios-modisviirs-procesados-opción-alternativa">Datos de incendios MODIS/VIIRS procesados (Opción alternativa)</a></li>
  <li><a href="#mostrar-cómo-importar-y-analizar-datos-modisviirs" id="toc-mostrar-cómo-importar-y-analizar-datos-modisviirs" class="nav-link" data-scroll-target="#mostrar-cómo-importar-y-analizar-datos-modisviirs">Mostrar cómo importar y analizar datos MODIS/VIIRS</a></li>
  <li><a href="#dashboard-firms" id="toc-dashboard-firms" class="nav-link" data-scroll-target="#dashboard-firms">Dashboard FIRMS</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Análisis de datos de incendios en Villa del Rosario</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
  <div class="quarto-categories">
    <div class="quarto-category">climate/environment</div>
    <div class="quarto-category">remote sensing</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 10, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<div class="cell">
<div class="cell-output-display">
<script>
  addClassKlippyTo("pre.r, pre.markdown");
  addKlippy('left', 'top', 'auto', '1', 'Copy code', 'Copied!');
</script>
</div>
</div>
<section id="pasos" class="level2">
<h2 class="anchored" data-anchor-id="pasos">Pasos</h2>
<section id="instalación-de-qgis" class="level3">
<h3 class="anchored" data-anchor-id="instalación-de-qgis">Instalación de QGIS</h3>
<ol type="1">
<li><p><strong>Instalar QGIS</strong>: Descargar e instalar desde <a href="https://qgis.org/download/">https://qgis.org/download/</a></p></li>
<li><p><strong>Instalar complementos</strong>:</p>
<ul>
<li>Abrir QGIS → Complementos → Administrar e instalar complementos</li>
<li>Buscar e instalar:
<ul>
<li>QuickMapServices</li>
<li>Mapbiomas</li>
<li>Google Earth Engine</li>
</ul></li>
</ul></li>
<li><p><strong>Crear conexiones WFS</strong>:</p>
<ul>
<li>Ir a Capa → Agregar capa → Agregar capa WFS</li>
<li>Crear nueva conexión:</li>
</ul>
<p><strong>IGN</strong>:</p>
<ul>
<li>Nombre: <code>IGN</code></li>
<li>URL: <code>https://wms.ign.gob.ar/geoserver/ign/ows?version=1.0.0</code></li>
<li>Conectar y explorar capas disponibles</li>
</ul>
<p><strong>IDECOR</strong>:</p>
<ul>
<li>Nombre: <code>IDECOR</code></li>
<li>URL: <code>https://idecor-ws.mapascordoba.gob.ar/geoserver/idecor/wfs</code></li>
<li>Conectar y explorar capas disponibles</li>
</ul>
<p>¡Agregar datos de incendios de IDECOR!</p></li>
</ol>
</section>
<section id="google-earth-engine" class="level3">
<h3 class="anchored" data-anchor-id="google-earth-engine">Google Earth Engine</h3>
<ol type="1">
<li><strong>Crear cuenta</strong>:
<ul>
<li>Ir a <a href="https://signup.earthengine.google.com/">https://signup.earthengine.google.com/</a></li>
<li>Registrarse como cuenta de investigación o académica</li>
<li><strong>Nota</strong>: Requiere cuenta de Gmail</li>
</ul></li>
<li><strong>Autenticar en QGIS</strong>:
<ul>
<li>Abrir QGIS</li>
<li>Ir a Complementos → Google Earth Engine</li>
<li>Seleccionar “Autenticar”</li>
<li>Se abrirá navegador para completar autenticación</li>
<li>Una vez autenticado, el plugin estará listo para usar</li>
</ul></li>
</ol>
</section>
<section id="descargar-los-siguientes-datasets" class="level3">
<h3 class="anchored" data-anchor-id="descargar-los-siguientes-datasets">Descargar los siguientes datasets</h3>
<ol type="1">
<li><strong>Área de interés (AOI)</strong>:
<ul>
<li>Descargar desde bucket AWS: <a href="https://arg-fulbright-data.s3.amazonaws.com/villa-del-rosario/datos/poligonal_coovilros.geojson">poligonal_coovilros.geojson</a></li>
<li><strong>Opción alternativa</strong>: Cargar directamente desde HTTPS en QGIS (ver consola abajo)</li>
</ul></li>
<li><strong>Pérdida global de bosque por incendios</strong>:
<ul>
<li><strong>Versión pequeña</strong> (recomendada): <a href="https://arg-fulbright-data.s3.amazonaws.com/villa-del-rosario/datos/bosque_perdido_a_fuego_2001-24.tif">bosque_perdido_a_fuego_2001-24.tif</a></li>
<li><strong>Versión completa</strong> (1.2GB): <a href="https://glad.umd.edu/users/Alexandra/Fire_GFL_data/2001-24/LAM_fire_forest_loss_2001-24.tif">LAM_fire_forest_loss_2001-24.tif</a></li>
<li><strong>Opción alternativa</strong>: Cargar directamente desde HTTPS en QGIS (ver consola abajo)</li>
</ul></li>
<li><strong>Datos Mapbiomas</strong>:
<ul>
<li>Intentar obtener datos para Argentina vía plugin (2022, año más reciente)</li>
<li><strong>Nota</strong>: El servidor WMS de Mapbiomas ha estado inestable últimamente</li>
</ul></li>
</ol>
<section id="respaldo-si-mapbiomas-no-funciona" class="level4">
<h4 class="anchored" data-anchor-id="respaldo-si-mapbiomas-no-funciona">Respaldo si Mapbiomas no funciona:</h4>
<ol type="1">
<li><strong>Descargar datos</strong>:
<ul>
<li>Descargar desde: <a href="https://arg-fulbright-data.s3.amazonaws.com/villa-del-rosario/datos/suelo_2022.tif">suelo_2022.tif</a></li>
<li>Nombrar capa como <code>suelo_2022</code></li>
</ul></li>
<li><strong>Ejecutar código de visualización</strong>:</li>
</ol>
<pre><code># Obtener la capa
layer = QgsProject.instance().mapLayersByName('suelo_2022')[0]

# Crear entradas de clase individuales para cada valor de píxel
classes = [
    QgsPalettedRasterRenderer.Class(3, QColor('#1f8d49'), 'Vegetación leñosa'),
    QgsPalettedRasterRenderer.Class(4, QColor('#1f8d49'), 'Vegetación leñosa'),
    QgsPalettedRasterRenderer.Class(45, QColor('#1f8d49'), 'Vegetación leñosa'),
    QgsPalettedRasterRenderer.Class(6, QColor('#1f8d49'), 'Vegetación leñosa'),
    QgsPalettedRasterRenderer.Class(11, QColor('#d6bc74'), 'Vegetación no leñosa'),
    QgsPalettedRasterRenderer.Class(12, QColor('#d6bc74'), 'Vegetación no leñosa'),
    QgsPalettedRasterRenderer.Class(63, QColor('#d6bc74'), 'Vegetación no leñosa'),
    QgsPalettedRasterRenderer.Class(15, QColor('#ffefc3'), 'Área agropecuaria'),
    QgsPalettedRasterRenderer.Class(18, QColor('#ffefc3'), 'Área agropecuaria'),
    QgsPalettedRasterRenderer.Class(9, QColor('#ffefc3'), 'Área agropecuaria'),
    QgsPalettedRasterRenderer.Class(36, QColor('#ffefc3'), 'Área agropecuaria'),
    QgsPalettedRasterRenderer.Class(21, QColor('#ffefc3'), 'Área agropecuaria'),
    QgsPalettedRasterRenderer.Class(22, QColor('#d4271e'), 'Área sin vegetación'),
    QgsPalettedRasterRenderer.Class(33, QColor('#2532e3'), 'Cuerpo de agua'),
    QgsPalettedRasterRenderer.Class(34, QColor('#2532e3'), 'Cuerpo de agua'),
    QgsPalettedRasterRenderer.Class(27, QColor('#ffffff'), 'No observado')
]

# Crear renderizador con clases
renderer = QgsPalettedRasterRenderer(layer.dataProvider(), 1, classes)

# Aplicar renderizador
layer.setRenderer(renderer)
layer.triggerRepaint()</code></pre>
</section>
</section>
<section id="datos-de-incendios-modisviirs-procesados-opción-alternativa" class="level3">
<h3 class="anchored" data-anchor-id="datos-de-incendios-modisviirs-procesados-opción-alternativa">Datos de incendios MODIS/VIIRS procesados (Opción alternativa)</h3>
<p>Si no puedes configurar una cuenta de Google Earth Engine, puedes usar los datos de incendios ya procesados:</p>
<ol type="1">
<li><strong>Datos MODIS procesados</strong>:
<ul>
<li>Descargar desde: <a href="https://arg-fulbright-data.s3.amazonaws.com/villa-del-rosario/datos/_all_modis.geojson">MODIS procesado</a></li>
<li>Contiene todos los incendios MODIS detectados en el área de estudio (2000-2020)</li>
</ul></li>
<li><strong>Datos VIIRS procesados</strong>:
<ul>
<li>Descargar desde: <a href="https://arg-fulbright-data.s3.amazonaws.com/villa-del-rosario/datos/_all_viirs.geojson">VIIRS procesado</a></li>
<li>Contiene todos los incendios VIIRS detectados en el área de estudio (2012-2021)</li>
</ul></li>
<li><strong>Cargar en QGIS</strong>:
<ul>
<li>Descargar ambos archivos GeoJSON</li>
<li>En QGIS: Capa → Agregar capa → Agregar capa vectorial</li>
<li>Seleccionar los archivos descargados</li>
<li>Nombrar las capas como <code>Incendios MODIS (2000-2020)</code> y <code>Incendios VIIRS (2012-2021)</code></li>
</ul></li>
</ol>
<p><strong>Nota</strong>: Si usas estos datos procesados, puedes proceder directamente al <strong>Paso 4</strong> (Preparar datos para agregación espacial y temporal) más abajo.</p>
</section>
<section id="mostrar-cómo-importar-y-analizar-datos-modisviirs" class="level3">
<h3 class="anchored" data-anchor-id="mostrar-cómo-importar-y-analizar-datos-modisviirs">Mostrar cómo importar y analizar datos MODIS/VIIRS</h3>
<section id="pasos-para-importar-acceso-gee" class="level4">
<h4 class="anchored" data-anchor-id="pasos-para-importar-acceso-gee">Pasos para importar (acceso GEE)</h4>
<p><strong>1. Instalar bibliotecas e inicializar Earth Engine</strong>: Primero necesitamos instalar geemap, una biblioteca de Python que facilita el trabajo con Google Earth Engine desde QGIS. También importamos todas las bibliotecas necesarias para el procesamiento de datos geoespaciales y inicializamos la conexión con Earth Engine.</p>
<pre><code># Instalar geemap
import pip
pip.main(['install', 'geemap'])

# Importar bibliotecas requeridas
import ee
import geemap
from qgis.core import QgsProject, QgsVectorLayer
import pandas as pd
import geopandas as gpd
from datetime import datetime
from shapely import wkt
import processing
import tempfile
import os

# Inicializar Earth Engine
ee.Initialize()</code></pre>
<p><strong>2. Importar capas y datos de incendios</strong>: En este paso obtenemos nuestra capa de área de interés (AOI) desde QGIS y la convertimos a un formato compatible con Earth Engine. Luego definimos los años disponibles para MODIS (2000-2020) y VIIRS (2012-2021) y creamos una función para cargar los datos de incendios por año desde los datasets públicos de Earth Engine.</p>
<pre><code># Obtener la capa AOI de QGIS
aoi_layer = QgsProject.instance().mapLayersByName('AOI')[0]

# Convertir la capa QGIS a GeoDataFrame
features = [feat for feat in aoi_layer.getFeatures()]
geoms = [feat.geometry().asWkt() for feat in features]

geoms_shapely = [wkt.loads(geom) for geom in geoms]
aoi = gpd.GeoDataFrame({'geometry': geoms_shapely}, crs=aoi_layer.crs().authid())

# Crear listas de todos los años disponibles
modis_years = list(range(2000, 2021))  # 2000-2020
viirs_years = list(range(2012, 2022))  # 2012-2021

# Función para crear FeatureCollection para un año y conjunto de datos específico
def crear_coleccion_incendios(conjunto_datos, año):
    """Crear un FeatureCollection para un conjunto de datos y año específico"""
    if conjunto_datos == 'modis':
        ruta = f"projects/sat-io/open-datasets/MODIS_MCD14DL/MCD14DL_{año}"
    elif conjunto_datos == 'viirs':
        ruta = f"projects/sat-io/open-datasets/VIIRS/VNP14IMGTDL_NRT_{año}"
    else:
        raise ValueError("El conjunto de datos debe ser 'modis' o 'viirs'")
    
    try:
        return ee.FeatureCollection(ruta)
    except Exception as e:
        print(f"Advertencia: No se pudieron cargar los datos de {conjunto_datos} para el año {año}: {e}")
        return None

# Cargar todos los datos MODIS (2000-2020)
print("Cargando datos MODIS (2000-2020)...")
colecciones_modis = []
for año in modis_years:
    coleccion = crear_coleccion_incendios('modis', año)
    if coleccion is not None:
        colecciones_modis.append(coleccion)

# Cargar todos los datos VIIRS (2012-2021)
print("Cargando datos VIIRS (2012-2021)...")
colecciones_viirs = []
for año in viirs_years:
    coleccion = crear_coleccion_incendios('viirs', año)
    if coleccion is not None:
        colecciones_viirs.append(coleccion)

# Combinar todas las colecciones en FeatureCollections únicas
print("Combinando todos los años...")
todos_modis = ee.FeatureCollection(colecciones_modis).flatten()
todos_viirs = ee.FeatureCollection(colecciones_viirs).flatten()

# Filtrar por área de interés
ee_aoi = geemap.geopandas_to_ee(aoi)
print("Filtrando por área de interés...")
todos_modis_aoi = todos_modis.filterBounds(ee_aoi)
todos_viirs_aoi = todos_viirs.filterBounds(ee_aoi)

print("¡Procesamiento completo!")
print(f"Incendios MODIS en AOI: {todos_modis_aoi.size().getInfo()}")
print(f"Incendios VIIRS en AOI: {todos_viirs_aoi.size().getInfo()}")</code></pre>
<p><strong>3. Agregar datos MODIS/VIIRS al mapa</strong>: Una vez que hemos cargado y filtrado todos los datos de incendios por nuestra área de interés, los agregamos al mapa de QGIS. Esto nos permite visualizar todos los puntos de incendios detectados por ambos satélites en nuestro área de estudio.</p>
<pre><code># Exportar a GeoJSON y agregar al mapa de QGIS
print("Exportando a archivos temporales y agregando al mapa...")

# Exportar MODIS
modis_temp = os.path.join(tempfile.gettempdir(), 'incendios_modis.geojson')
geemap.ee_to_geojson(todos_modis_aoi, modis_temp)
capa_modis = QgsVectorLayer(modis_temp, 'Incendios MODIS (2000-2020)', 'ogr')
QgsProject.instance().addMapLayer(capa_modis)

# Exportar VIIRS
viirs_temp = os.path.join(tempfile.gettempdir(), 'incendios_viirs.geojson')
geemap.ee_to_geojson(todos_viirs_aoi, viirs_temp)
capa_viirs = QgsVectorLayer(viirs_temp, 'Incendios VIIRS (2012-2021)', 'ogr')
QgsProject.instance().addMapLayer(capa_viirs)

print("¡Capas agregadas al mapa!")</code></pre>
</section>
<section id="pasos-para-analizar-cuadrícula-hexagonal" class="level4">
<h4 class="anchored" data-anchor-id="pasos-para-analizar-cuadrícula-hexagonal">Pasos para analizar (cuadrícula hexagonal)</h4>
<p><strong>4. Preparar datos para agregación espacial y temporal</strong>: Ahora necesitamos procesar los datos de incendios para poder analizarlos espacialmente. Extraemos solo la geometría y fecha de cada incendio, y los combinamos en un solo dataset. Luego agrupamos por geometría y mes para obtener observaciones únicas por mes, eliminando duplicados temporales.</p>
<pre><code># Obtener las capas de incendios del proyecto QGIS
print("Obteniendo capas de incendios...")
capa_modis = QgsProject.instance().mapLayersByName('Incendios MODIS (2000-2020)')[0]
capa_viirs = QgsProject.instance().mapLayersByName('Incendios VIIRS (2012-2021)')[0]

# Convertir capas QGIS a GeoDataFrames con conversión de fechas
print("Convirtiendo capas a GeoDataFrames...")

def qgis_to_gdf_with_dates(layer):
    """Convertir capa QGIS a GeoDataFrame con fechas correctamente formateadas"""
    features = []
    for f in layer.getFeatures():
        attrs = dict(zip([field.name() for field in f.fields()], f.attributes()))
        geom = f.geometry()
        
        # Convertir QDate a datetime de Python
        if 'acq_date' in attrs:
            qdate = attrs['acq_date']
            if qdate is not None:
                attrs['acq_date'] = datetime(qdate.year(), qdate.month(), qdate.day())
        
        attrs['geometry'] = wkt.loads(geom.asWkt())
        features.append(attrs)
    
    gdf = gpd.GeoDataFrame(features, geometry='geometry', crs=layer.crs().authid())
    return gdf

modis_gdf = qgis_to_gdf_with_dates(capa_modis)
viirs_gdf = qgis_to_gdf_with_dates(capa_viirs)

# Reproyectar a EPSG:5347
modis_gdf = modis_gdf.to_crs('EPSG:5347')
viirs_gdf = viirs_gdf.to_crs('EPSG:5347')

# 1. Extraer solo geometría y fecha de ambos gdfs
print("Extrayendo geometría y fecha de los datos MODIS...")
modis_subset = modis_gdf[['geometry', 'acq_date']].copy()
modis_subset['source'] = 'MODIS'

print("Extrayendo geometría y fecha de los datos VIIRS...")
viirs_subset = viirs_gdf[['geometry', 'acq_date']].copy()
viirs_subset['source'] = 'VIIRS'

# 2. Concatenar en un solo dataframe
print("Concatenando dataframes...")
combined_gdf = pd.concat([modis_subset, viirs_subset], ignore_index=True)
combined_gdf = gpd.GeoDataFrame(combined_gdf, geometry='geometry', crs='EPSG:5347')

# 3. Extraer año-mes de acq_date y agrupar por geometría, año-mes
print("Procesando fechas y agrupando...")
combined_gdf['acq_date'] = pd.to_datetime(combined_gdf['acq_date'])
combined_gdf['year_month'] = combined_gdf['acq_date'].dt.to_period('M')

# Agrupar por geometría y año-mes para obtener observaciones únicas por mes
grouped = combined_gdf.groupby(['geometry', 'year_month']).size().reset_index(name='count')
grouped_gdf = gpd.GeoDataFrame(grouped, geometry='geometry', crs='EPSG:5347')
print(f"Total de combinaciones únicas geometría-mes: {len(grouped_gdf)}")</code></pre>
<p><strong>5. Crear cuadrícula hexagonal de 1km (resolución máxima de MODIS)</strong>: Para analizar los patrones espaciales de incendios, creamos una cuadrícula hexagonal de 1km de espaciado. Elegimos hexágonos porque proporcionan una mejor distribución espacial que cuadrados, y 1km porque es la resolución máxima de los datos MODIS. Esto significa que no podemos agregar a una escala menor sin perder precisión.</p>
<pre><code># 4. Crear una cuadrícula hexagonal con 1km de espaciado usando QGIS
print("Creando cuadrícula hexagonal...")
aoi_layer = QgsProject.instance().mapLayersByName('AOI')[0]

hex_result = processing.run("native:creategrid", {
    'TYPE': 4,
    'EXTENT': aoi_layer.extent(),
    'HSPACING': 1000,
    'VSPACING': 1000,
    'HOVERLAY': 0,
    'VOVERLAY': 0,
    'CRS': aoi_layer.crs(),
    'OUTPUT': 'memory:'
})

hex_layer = hex_result['OUTPUT']
print(f"Creados {hex_layer.featureCount()} celdas hexagonales")</code></pre>
<p><strong>6. Unir observaciones a cuadrícula y contar</strong>: Finalmente, unimos nuestros puntos de incendios con la cuadrícula hexagonal usando operaciones espaciales. Contamos dos métricas importantes: el número de meses únicos con observaciones por hexágono (frecuencia temporal) y el número total de observaciones por hexágono (intensidad). Esto nos da una visión completa de los patrones de incendios en el espacio y tiempo.</p>
<pre><code># Convertir capa hexagonal a GeoDataFrame
hex_features = []
for f in hex_layer.getFeatures():
    hex_features.append({'geometry': wkt.loads(f.geometry().asWkt())})

hex_gdf = gpd.GeoDataFrame(hex_features, geometry='geometry', crs=hex_layer.crs().authid())
hex_gdf = hex_gdf.to_crs('EPSG:5347')
hex_gdf['cell_id'] = hex_gdf.index

# 5. Contar número de meses por hexágono con al menos una observación
print("Contando meses por hexágono...")
points_in_hex = gpd.sjoin(grouped_gdf, hex_gdf, how='left', predicate='within')

# Contar meses únicos por hexágono
months_per_hex = points_in_hex.groupby('cell_id')['year_month'].nunique().reset_index(name='meses_con_observaciones')

# 6. Contar observaciones totales por hexágono
print("Contando observaciones totales por hexágono...")
total_obs_per_hex = points_in_hex.groupby('cell_id')['count'].sum().reset_index(name='observaciones_totales')

# Combinar ambas métricas en un solo GeoDataFrame
hex_final = hex_gdf.merge(months_per_hex, on='cell_id', how='left')
hex_final = hex_final.merge(total_obs_per_hex, on='cell_id', how='left')
hex_final['meses_con_observaciones'] = hex_final['meses_con_observaciones'].fillna(0)
hex_final['observaciones_totales'] = hex_final['observaciones_totales'].fillna(0)

# Guardar como capa temporal y agregar al mapa
print("Agregando cuadrícula hexagonal al mapa...")
hex_temp = os.path.join(tempfile.gettempdir(), 'cuadricula_hexagonal_incendios.geojson')
hex_final.to_file(hex_temp, driver='GeoJSON')
hex_final_layer = QgsVectorLayer(hex_temp, 'Cuadrícula Hexagonal - Incendios', 'ogr')
QgsProject.instance().addMapLayer(hex_final_layer)

print("¡Agregación completada!")
print(f"Meses máximos con observaciones en un hexágono: {hex_final['meses_con_observaciones'].max()}")
print(f"Observaciones totales máximas en un hexágono: {hex_final['observaciones_totales'].max()}")</code></pre>
</section>
</section>
<section id="dashboard-firms" class="level3">
<h3 class="anchored" data-anchor-id="dashboard-firms">Dashboard FIRMS</h3>
<section id="explorar-dashboard" class="level4">
<h4 class="anchored" data-anchor-id="explorar-dashboard">Explorar dashboard</h4>
<section id="explicar-qué-pueden-y-no-pueden-hacer-los-datos" class="level5">
<h5 class="anchored" data-anchor-id="explicar-qué-pueden-y-no-pueden-hacer-los-datos">Explicar qué pueden y no pueden hacer los datos</h5>
</section>
</section>
<section id="configurar-alertas-para-aoi-subiendo-archivo-de-límites" class="level4">
<h4 class="anchored" data-anchor-id="configurar-alertas-para-aoi-subiendo-archivo-de-límites">Configurar alertas para AOI subiendo archivo de límites</h4>


<!-- -->

</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb8" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Análisis de datos de incendios en Villa del Rosario"</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> 09-10-2025 </span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="an">categories:</span><span class="co"> [climate/environment, remote sensing]</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="in">```{r klippy, echo=FALSE, include=TRUE}</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="in">klippy::klippy()</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="fu">## Pasos</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="fu">### Instalación de QGIS</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Instalar QGIS**: Descargar e instalar desde <span class="co">[</span><span class="ot">https://qgis.org/download/</span><span class="co">](https://qgis.org/download/)</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Instalar complementos**:</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Abrir QGIS → Complementos → Administrar e instalar complementos</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Buscar e instalar:</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="ss">     - </span>QuickMapServices</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="ss">     - </span>Mapbiomas</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="ss">     - </span>Google Earth Engine</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Crear conexiones WFS**:</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Ir a Capa → Agregar capa → Agregar capa WFS</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Crear nueva conexión:</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>   **IGN**:</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Nombre: <span class="in">`IGN`</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>URL: <span class="in">`https://wms.ign.gob.ar/geoserver/ign/ows?version=1.0.0`</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Conectar y explorar capas disponibles</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>   **IDECOR**:</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Nombre: <span class="in">`IDECOR`</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>URL: <span class="in">`https://idecor-ws.mapascordoba.gob.ar/geoserver/idecor/wfs`</span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Conectar y explorar capas disponibles</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>   ¡Agregar datos de incendios de IDECOR!</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a><span class="fu">### Google Earth Engine</span></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Crear cuenta**:</span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Ir a <span class="co">[</span><span class="ot">https://signup.earthengine.google.com/</span><span class="co">](https://signup.earthengine.google.com/)</span></span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Registrarse como cuenta de investigación o académica</span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**Nota**: Requiere cuenta de Gmail</span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Autenticar en QGIS**:</span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Abrir QGIS</span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Ir a Complementos → Google Earth Engine</span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Seleccionar "Autenticar"</span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Se abrirá navegador para completar autenticación</span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Una vez autenticado, el plugin estará listo para usar</span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a><span class="fu">### Descargar los siguientes datasets</span></span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Área de interés (AOI)**:</span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Descargar desde bucket AWS: <span class="co">[</span><span class="ot">poligonal_coovilros.geojson</span><span class="co">](https://arg-fulbright-data.s3.amazonaws.com/villa-del-rosario/datos/poligonal_coovilros.geojson)</span></span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**Opción alternativa**: Cargar directamente desde HTTPS en QGIS (ver consola abajo)</span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Pérdida global de bosque por incendios**:</span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**Versión pequeña** (recomendada): <span class="co">[</span><span class="ot">bosque_perdido_a_fuego_2001-24.tif</span><span class="co">](https://arg-fulbright-data.s3.amazonaws.com/villa-del-rosario/datos/bosque_perdido_a_fuego_2001-24.tif)</span></span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**Versión completa** (1.2GB): <span class="co">[</span><span class="ot">LAM_fire_forest_loss_2001-24.tif</span><span class="co">](https://glad.umd.edu/users/Alexandra/Fire_GFL_data/2001-24/LAM_fire_forest_loss_2001-24.tif)</span></span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**Opción alternativa**: Cargar directamente desde HTTPS en QGIS (ver consola abajo)</span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-65"><a href="#cb8-65" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Datos Mapbiomas**:</span>
<span id="cb8-66"><a href="#cb8-66" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Intentar obtener datos para Argentina vía plugin (2022, año más reciente)</span>
<span id="cb8-67"><a href="#cb8-67" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**Nota**: El servidor WMS de Mapbiomas ha estado inestable últimamente</span>
<span id="cb8-68"><a href="#cb8-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-69"><a href="#cb8-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-70"><a href="#cb8-70" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Respaldo si Mapbiomas no funciona:</span></span>
<span id="cb8-71"><a href="#cb8-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-72"><a href="#cb8-72" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Descargar datos**:</span>
<span id="cb8-73"><a href="#cb8-73" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Descargar desde: <span class="co">[</span><span class="ot">suelo_2022.tif</span><span class="co">](https://arg-fulbright-data.s3.amazonaws.com/villa-del-rosario/datos/suelo_2022.tif)</span></span>
<span id="cb8-74"><a href="#cb8-74" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Nombrar capa como <span class="in">`suelo_2022`</span></span>
<span id="cb8-75"><a href="#cb8-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-76"><a href="#cb8-76" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Ejecutar código de visualización**:</span>
<span id="cb8-77"><a href="#cb8-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-78"><a href="#cb8-78" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb8-79"><a href="#cb8-79" aria-hidden="true" tabindex="-1"></a><span class="in"># Obtener la capa</span></span>
<span id="cb8-80"><a href="#cb8-80" aria-hidden="true" tabindex="-1"></a><span class="in">layer = QgsProject.instance().mapLayersByName('suelo_2022')[0]</span></span>
<span id="cb8-81"><a href="#cb8-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-82"><a href="#cb8-82" aria-hidden="true" tabindex="-1"></a><span class="in"># Crear entradas de clase individuales para cada valor de píxel</span></span>
<span id="cb8-83"><a href="#cb8-83" aria-hidden="true" tabindex="-1"></a><span class="in">classes = [</span></span>
<span id="cb8-84"><a href="#cb8-84" aria-hidden="true" tabindex="-1"></a><span class="in">    QgsPalettedRasterRenderer.Class(3, QColor('#1f8d49'), 'Vegetación leñosa'),</span></span>
<span id="cb8-85"><a href="#cb8-85" aria-hidden="true" tabindex="-1"></a><span class="in">    QgsPalettedRasterRenderer.Class(4, QColor('#1f8d49'), 'Vegetación leñosa'),</span></span>
<span id="cb8-86"><a href="#cb8-86" aria-hidden="true" tabindex="-1"></a><span class="in">    QgsPalettedRasterRenderer.Class(45, QColor('#1f8d49'), 'Vegetación leñosa'),</span></span>
<span id="cb8-87"><a href="#cb8-87" aria-hidden="true" tabindex="-1"></a><span class="in">    QgsPalettedRasterRenderer.Class(6, QColor('#1f8d49'), 'Vegetación leñosa'),</span></span>
<span id="cb8-88"><a href="#cb8-88" aria-hidden="true" tabindex="-1"></a><span class="in">    QgsPalettedRasterRenderer.Class(11, QColor('#d6bc74'), 'Vegetación no leñosa'),</span></span>
<span id="cb8-89"><a href="#cb8-89" aria-hidden="true" tabindex="-1"></a><span class="in">    QgsPalettedRasterRenderer.Class(12, QColor('#d6bc74'), 'Vegetación no leñosa'),</span></span>
<span id="cb8-90"><a href="#cb8-90" aria-hidden="true" tabindex="-1"></a><span class="in">    QgsPalettedRasterRenderer.Class(63, QColor('#d6bc74'), 'Vegetación no leñosa'),</span></span>
<span id="cb8-91"><a href="#cb8-91" aria-hidden="true" tabindex="-1"></a><span class="in">    QgsPalettedRasterRenderer.Class(15, QColor('#ffefc3'), 'Área agropecuaria'),</span></span>
<span id="cb8-92"><a href="#cb8-92" aria-hidden="true" tabindex="-1"></a><span class="in">    QgsPalettedRasterRenderer.Class(18, QColor('#ffefc3'), 'Área agropecuaria'),</span></span>
<span id="cb8-93"><a href="#cb8-93" aria-hidden="true" tabindex="-1"></a><span class="in">    QgsPalettedRasterRenderer.Class(9, QColor('#ffefc3'), 'Área agropecuaria'),</span></span>
<span id="cb8-94"><a href="#cb8-94" aria-hidden="true" tabindex="-1"></a><span class="in">    QgsPalettedRasterRenderer.Class(36, QColor('#ffefc3'), 'Área agropecuaria'),</span></span>
<span id="cb8-95"><a href="#cb8-95" aria-hidden="true" tabindex="-1"></a><span class="in">    QgsPalettedRasterRenderer.Class(21, QColor('#ffefc3'), 'Área agropecuaria'),</span></span>
<span id="cb8-96"><a href="#cb8-96" aria-hidden="true" tabindex="-1"></a><span class="in">    QgsPalettedRasterRenderer.Class(22, QColor('#d4271e'), 'Área sin vegetación'),</span></span>
<span id="cb8-97"><a href="#cb8-97" aria-hidden="true" tabindex="-1"></a><span class="in">    QgsPalettedRasterRenderer.Class(33, QColor('#2532e3'), 'Cuerpo de agua'),</span></span>
<span id="cb8-98"><a href="#cb8-98" aria-hidden="true" tabindex="-1"></a><span class="in">    QgsPalettedRasterRenderer.Class(34, QColor('#2532e3'), 'Cuerpo de agua'),</span></span>
<span id="cb8-99"><a href="#cb8-99" aria-hidden="true" tabindex="-1"></a><span class="in">    QgsPalettedRasterRenderer.Class(27, QColor('#ffffff'), 'No observado')</span></span>
<span id="cb8-100"><a href="#cb8-100" aria-hidden="true" tabindex="-1"></a><span class="in">]</span></span>
<span id="cb8-101"><a href="#cb8-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-102"><a href="#cb8-102" aria-hidden="true" tabindex="-1"></a><span class="in"># Crear renderizador con clases</span></span>
<span id="cb8-103"><a href="#cb8-103" aria-hidden="true" tabindex="-1"></a><span class="in">renderer = QgsPalettedRasterRenderer(layer.dataProvider(), 1, classes)</span></span>
<span id="cb8-104"><a href="#cb8-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-105"><a href="#cb8-105" aria-hidden="true" tabindex="-1"></a><span class="in"># Aplicar renderizador</span></span>
<span id="cb8-106"><a href="#cb8-106" aria-hidden="true" tabindex="-1"></a><span class="in">layer.setRenderer(renderer)</span></span>
<span id="cb8-107"><a href="#cb8-107" aria-hidden="true" tabindex="-1"></a><span class="in">layer.triggerRepaint()</span></span>
<span id="cb8-108"><a href="#cb8-108" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb8-109"><a href="#cb8-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-110"><a href="#cb8-110" aria-hidden="true" tabindex="-1"></a><span class="fu">### Datos de incendios MODIS/VIIRS procesados (Opción alternativa)</span></span>
<span id="cb8-111"><a href="#cb8-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-112"><a href="#cb8-112" aria-hidden="true" tabindex="-1"></a>Si no puedes configurar una cuenta de Google Earth Engine, puedes usar los datos de incendios ya procesados:</span>
<span id="cb8-113"><a href="#cb8-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-114"><a href="#cb8-114" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Datos MODIS procesados**:</span>
<span id="cb8-115"><a href="#cb8-115" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Descargar desde: <span class="co">[</span><span class="ot">MODIS procesado</span><span class="co">](https://arg-fulbright-data.s3.amazonaws.com/villa-del-rosario/datos/_all_modis.geojson)</span></span>
<span id="cb8-116"><a href="#cb8-116" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Contiene todos los incendios MODIS detectados en el área de estudio (2000-2020)</span>
<span id="cb8-117"><a href="#cb8-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-118"><a href="#cb8-118" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Datos VIIRS procesados**:</span>
<span id="cb8-119"><a href="#cb8-119" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Descargar desde: <span class="co">[</span><span class="ot">VIIRS procesado</span><span class="co">](https://arg-fulbright-data.s3.amazonaws.com/villa-del-rosario/datos/_all_viirs.geojson)</span></span>
<span id="cb8-120"><a href="#cb8-120" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Contiene todos los incendios VIIRS detectados en el área de estudio (2012-2021)</span>
<span id="cb8-121"><a href="#cb8-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-122"><a href="#cb8-122" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Cargar en QGIS**:</span>
<span id="cb8-123"><a href="#cb8-123" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Descargar ambos archivos GeoJSON</span>
<span id="cb8-124"><a href="#cb8-124" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>En QGIS: Capa → Agregar capa → Agregar capa vectorial</span>
<span id="cb8-125"><a href="#cb8-125" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Seleccionar los archivos descargados</span>
<span id="cb8-126"><a href="#cb8-126" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Nombrar las capas como <span class="in">`Incendios MODIS (2000-2020)`</span> y <span class="in">`Incendios VIIRS (2012-2021)`</span></span>
<span id="cb8-127"><a href="#cb8-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-128"><a href="#cb8-128" aria-hidden="true" tabindex="-1"></a>**Nota**: Si usas estos datos procesados, puedes proceder directamente al **Paso 4** (Preparar datos para agregación espacial y temporal) más abajo.</span>
<span id="cb8-129"><a href="#cb8-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-130"><a href="#cb8-130" aria-hidden="true" tabindex="-1"></a><span class="fu">### Mostrar cómo importar y analizar datos MODIS/VIIRS</span></span>
<span id="cb8-131"><a href="#cb8-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-132"><a href="#cb8-132" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Pasos para importar (acceso GEE)</span></span>
<span id="cb8-133"><a href="#cb8-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-134"><a href="#cb8-134" aria-hidden="true" tabindex="-1"></a>**1. Instalar bibliotecas e inicializar Earth Engine**:</span>
<span id="cb8-135"><a href="#cb8-135" aria-hidden="true" tabindex="-1"></a>Primero necesitamos instalar geemap, una biblioteca de Python que facilita el trabajo con Google Earth Engine desde QGIS. También importamos todas las bibliotecas necesarias para el procesamiento de datos geoespaciales y inicializamos la conexión con Earth Engine.</span>
<span id="cb8-136"><a href="#cb8-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-137"><a href="#cb8-137" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb8-138"><a href="#cb8-138" aria-hidden="true" tabindex="-1"></a><span class="in"># Instalar geemap</span></span>
<span id="cb8-139"><a href="#cb8-139" aria-hidden="true" tabindex="-1"></a><span class="in">import pip</span></span>
<span id="cb8-140"><a href="#cb8-140" aria-hidden="true" tabindex="-1"></a><span class="in">pip.main(['install', 'geemap'])</span></span>
<span id="cb8-141"><a href="#cb8-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-142"><a href="#cb8-142" aria-hidden="true" tabindex="-1"></a><span class="in"># Importar bibliotecas requeridas</span></span>
<span id="cb8-143"><a href="#cb8-143" aria-hidden="true" tabindex="-1"></a><span class="in">import ee</span></span>
<span id="cb8-144"><a href="#cb8-144" aria-hidden="true" tabindex="-1"></a><span class="in">import geemap</span></span>
<span id="cb8-145"><a href="#cb8-145" aria-hidden="true" tabindex="-1"></a><span class="in">from qgis.core import QgsProject, QgsVectorLayer</span></span>
<span id="cb8-146"><a href="#cb8-146" aria-hidden="true" tabindex="-1"></a><span class="in">import pandas as pd</span></span>
<span id="cb8-147"><a href="#cb8-147" aria-hidden="true" tabindex="-1"></a><span class="in">import geopandas as gpd</span></span>
<span id="cb8-148"><a href="#cb8-148" aria-hidden="true" tabindex="-1"></a><span class="in">from datetime import datetime</span></span>
<span id="cb8-149"><a href="#cb8-149" aria-hidden="true" tabindex="-1"></a><span class="in">from shapely import wkt</span></span>
<span id="cb8-150"><a href="#cb8-150" aria-hidden="true" tabindex="-1"></a><span class="in">import processing</span></span>
<span id="cb8-151"><a href="#cb8-151" aria-hidden="true" tabindex="-1"></a><span class="in">import tempfile</span></span>
<span id="cb8-152"><a href="#cb8-152" aria-hidden="true" tabindex="-1"></a><span class="in">import os</span></span>
<span id="cb8-153"><a href="#cb8-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-154"><a href="#cb8-154" aria-hidden="true" tabindex="-1"></a><span class="in"># Inicializar Earth Engine</span></span>
<span id="cb8-155"><a href="#cb8-155" aria-hidden="true" tabindex="-1"></a><span class="in">ee.Initialize()</span></span>
<span id="cb8-156"><a href="#cb8-156" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb8-157"><a href="#cb8-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-158"><a href="#cb8-158" aria-hidden="true" tabindex="-1"></a>**2. Importar capas y datos de incendios**:</span>
<span id="cb8-159"><a href="#cb8-159" aria-hidden="true" tabindex="-1"></a>En este paso obtenemos nuestra capa de área de interés (AOI) desde QGIS y la convertimos a un formato compatible con Earth Engine. Luego definimos los años disponibles para MODIS (2000-2020) y VIIRS (2012-2021) y creamos una función para cargar los datos de incendios por año desde los datasets públicos de Earth Engine.</span>
<span id="cb8-160"><a href="#cb8-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-161"><a href="#cb8-161" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb8-162"><a href="#cb8-162" aria-hidden="true" tabindex="-1"></a><span class="in"># Obtener la capa AOI de QGIS</span></span>
<span id="cb8-163"><a href="#cb8-163" aria-hidden="true" tabindex="-1"></a><span class="in">aoi_layer = QgsProject.instance().mapLayersByName('AOI')[0]</span></span>
<span id="cb8-164"><a href="#cb8-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-165"><a href="#cb8-165" aria-hidden="true" tabindex="-1"></a><span class="in"># Convertir la capa QGIS a GeoDataFrame</span></span>
<span id="cb8-166"><a href="#cb8-166" aria-hidden="true" tabindex="-1"></a><span class="in">features = [feat for feat in aoi_layer.getFeatures()]</span></span>
<span id="cb8-167"><a href="#cb8-167" aria-hidden="true" tabindex="-1"></a><span class="in">geoms = [feat.geometry().asWkt() for feat in features]</span></span>
<span id="cb8-168"><a href="#cb8-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-169"><a href="#cb8-169" aria-hidden="true" tabindex="-1"></a><span class="in">geoms_shapely = [wkt.loads(geom) for geom in geoms]</span></span>
<span id="cb8-170"><a href="#cb8-170" aria-hidden="true" tabindex="-1"></a><span class="in">aoi = gpd.GeoDataFrame({'geometry': geoms_shapely}, crs=aoi_layer.crs().authid())</span></span>
<span id="cb8-171"><a href="#cb8-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-172"><a href="#cb8-172" aria-hidden="true" tabindex="-1"></a><span class="in"># Crear listas de todos los años disponibles</span></span>
<span id="cb8-173"><a href="#cb8-173" aria-hidden="true" tabindex="-1"></a><span class="in">modis_years = list(range(2000, 2021))  # 2000-2020</span></span>
<span id="cb8-174"><a href="#cb8-174" aria-hidden="true" tabindex="-1"></a><span class="in">viirs_years = list(range(2012, 2022))  # 2012-2021</span></span>
<span id="cb8-175"><a href="#cb8-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-176"><a href="#cb8-176" aria-hidden="true" tabindex="-1"></a><span class="in"># Función para crear FeatureCollection para un año y conjunto de datos específico</span></span>
<span id="cb8-177"><a href="#cb8-177" aria-hidden="true" tabindex="-1"></a><span class="in">def crear_coleccion_incendios(conjunto_datos, año):</span></span>
<span id="cb8-178"><a href="#cb8-178" aria-hidden="true" tabindex="-1"></a><span class="in">    """Crear un FeatureCollection para un conjunto de datos y año específico"""</span></span>
<span id="cb8-179"><a href="#cb8-179" aria-hidden="true" tabindex="-1"></a><span class="in">    if conjunto_datos == 'modis':</span></span>
<span id="cb8-180"><a href="#cb8-180" aria-hidden="true" tabindex="-1"></a><span class="in">        ruta = f"projects/sat-io/open-datasets/MODIS_MCD14DL/MCD14DL_{año}"</span></span>
<span id="cb8-181"><a href="#cb8-181" aria-hidden="true" tabindex="-1"></a><span class="in">    elif conjunto_datos == 'viirs':</span></span>
<span id="cb8-182"><a href="#cb8-182" aria-hidden="true" tabindex="-1"></a><span class="in">        ruta = f"projects/sat-io/open-datasets/VIIRS/VNP14IMGTDL_NRT_{año}"</span></span>
<span id="cb8-183"><a href="#cb8-183" aria-hidden="true" tabindex="-1"></a><span class="in">    else:</span></span>
<span id="cb8-184"><a href="#cb8-184" aria-hidden="true" tabindex="-1"></a><span class="in">        raise ValueError("El conjunto de datos debe ser 'modis' o 'viirs'")</span></span>
<span id="cb8-185"><a href="#cb8-185" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb8-186"><a href="#cb8-186" aria-hidden="true" tabindex="-1"></a><span class="in">    try:</span></span>
<span id="cb8-187"><a href="#cb8-187" aria-hidden="true" tabindex="-1"></a><span class="in">        return ee.FeatureCollection(ruta)</span></span>
<span id="cb8-188"><a href="#cb8-188" aria-hidden="true" tabindex="-1"></a><span class="in">    except Exception as e:</span></span>
<span id="cb8-189"><a href="#cb8-189" aria-hidden="true" tabindex="-1"></a><span class="in">        print(f"Advertencia: No se pudieron cargar los datos de {conjunto_datos} para el año {año}: {e}")</span></span>
<span id="cb8-190"><a href="#cb8-190" aria-hidden="true" tabindex="-1"></a><span class="in">        return None</span></span>
<span id="cb8-191"><a href="#cb8-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-192"><a href="#cb8-192" aria-hidden="true" tabindex="-1"></a><span class="in"># Cargar todos los datos MODIS (2000-2020)</span></span>
<span id="cb8-193"><a href="#cb8-193" aria-hidden="true" tabindex="-1"></a><span class="in">print("Cargando datos MODIS (2000-2020)...")</span></span>
<span id="cb8-194"><a href="#cb8-194" aria-hidden="true" tabindex="-1"></a><span class="in">colecciones_modis = []</span></span>
<span id="cb8-195"><a href="#cb8-195" aria-hidden="true" tabindex="-1"></a><span class="in">for año in modis_years:</span></span>
<span id="cb8-196"><a href="#cb8-196" aria-hidden="true" tabindex="-1"></a><span class="in">    coleccion = crear_coleccion_incendios('modis', año)</span></span>
<span id="cb8-197"><a href="#cb8-197" aria-hidden="true" tabindex="-1"></a><span class="in">    if coleccion is not None:</span></span>
<span id="cb8-198"><a href="#cb8-198" aria-hidden="true" tabindex="-1"></a><span class="in">        colecciones_modis.append(coleccion)</span></span>
<span id="cb8-199"><a href="#cb8-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-200"><a href="#cb8-200" aria-hidden="true" tabindex="-1"></a><span class="in"># Cargar todos los datos VIIRS (2012-2021)</span></span>
<span id="cb8-201"><a href="#cb8-201" aria-hidden="true" tabindex="-1"></a><span class="in">print("Cargando datos VIIRS (2012-2021)...")</span></span>
<span id="cb8-202"><a href="#cb8-202" aria-hidden="true" tabindex="-1"></a><span class="in">colecciones_viirs = []</span></span>
<span id="cb8-203"><a href="#cb8-203" aria-hidden="true" tabindex="-1"></a><span class="in">for año in viirs_years:</span></span>
<span id="cb8-204"><a href="#cb8-204" aria-hidden="true" tabindex="-1"></a><span class="in">    coleccion = crear_coleccion_incendios('viirs', año)</span></span>
<span id="cb8-205"><a href="#cb8-205" aria-hidden="true" tabindex="-1"></a><span class="in">    if coleccion is not None:</span></span>
<span id="cb8-206"><a href="#cb8-206" aria-hidden="true" tabindex="-1"></a><span class="in">        colecciones_viirs.append(coleccion)</span></span>
<span id="cb8-207"><a href="#cb8-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-208"><a href="#cb8-208" aria-hidden="true" tabindex="-1"></a><span class="in"># Combinar todas las colecciones en FeatureCollections únicas</span></span>
<span id="cb8-209"><a href="#cb8-209" aria-hidden="true" tabindex="-1"></a><span class="in">print("Combinando todos los años...")</span></span>
<span id="cb8-210"><a href="#cb8-210" aria-hidden="true" tabindex="-1"></a><span class="in">todos_modis = ee.FeatureCollection(colecciones_modis).flatten()</span></span>
<span id="cb8-211"><a href="#cb8-211" aria-hidden="true" tabindex="-1"></a><span class="in">todos_viirs = ee.FeatureCollection(colecciones_viirs).flatten()</span></span>
<span id="cb8-212"><a href="#cb8-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-213"><a href="#cb8-213" aria-hidden="true" tabindex="-1"></a><span class="in"># Filtrar por área de interés</span></span>
<span id="cb8-214"><a href="#cb8-214" aria-hidden="true" tabindex="-1"></a><span class="in">ee_aoi = geemap.geopandas_to_ee(aoi)</span></span>
<span id="cb8-215"><a href="#cb8-215" aria-hidden="true" tabindex="-1"></a><span class="in">print("Filtrando por área de interés...")</span></span>
<span id="cb8-216"><a href="#cb8-216" aria-hidden="true" tabindex="-1"></a><span class="in">todos_modis_aoi = todos_modis.filterBounds(ee_aoi)</span></span>
<span id="cb8-217"><a href="#cb8-217" aria-hidden="true" tabindex="-1"></a><span class="in">todos_viirs_aoi = todos_viirs.filterBounds(ee_aoi)</span></span>
<span id="cb8-218"><a href="#cb8-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-219"><a href="#cb8-219" aria-hidden="true" tabindex="-1"></a><span class="in">print("¡Procesamiento completo!")</span></span>
<span id="cb8-220"><a href="#cb8-220" aria-hidden="true" tabindex="-1"></a><span class="in">print(f"Incendios MODIS en AOI: {todos_modis_aoi.size().getInfo()}")</span></span>
<span id="cb8-221"><a href="#cb8-221" aria-hidden="true" tabindex="-1"></a><span class="in">print(f"Incendios VIIRS en AOI: {todos_viirs_aoi.size().getInfo()}")</span></span>
<span id="cb8-222"><a href="#cb8-222" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb8-223"><a href="#cb8-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-224"><a href="#cb8-224" aria-hidden="true" tabindex="-1"></a>**3. Agregar datos MODIS/VIIRS al mapa**:</span>
<span id="cb8-225"><a href="#cb8-225" aria-hidden="true" tabindex="-1"></a>Una vez que hemos cargado y filtrado todos los datos de incendios por nuestra área de interés, los agregamos al mapa de QGIS. Esto nos permite visualizar todos los puntos de incendios detectados por ambos satélites en nuestro área de estudio.</span>
<span id="cb8-226"><a href="#cb8-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-227"><a href="#cb8-227" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb8-228"><a href="#cb8-228" aria-hidden="true" tabindex="-1"></a><span class="in"># Exportar a GeoJSON y agregar al mapa de QGIS</span></span>
<span id="cb8-229"><a href="#cb8-229" aria-hidden="true" tabindex="-1"></a><span class="in">print("Exportando a archivos temporales y agregando al mapa...")</span></span>
<span id="cb8-230"><a href="#cb8-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-231"><a href="#cb8-231" aria-hidden="true" tabindex="-1"></a><span class="in"># Exportar MODIS</span></span>
<span id="cb8-232"><a href="#cb8-232" aria-hidden="true" tabindex="-1"></a><span class="in">modis_temp = os.path.join(tempfile.gettempdir(), 'incendios_modis.geojson')</span></span>
<span id="cb8-233"><a href="#cb8-233" aria-hidden="true" tabindex="-1"></a><span class="in">geemap.ee_to_geojson(todos_modis_aoi, modis_temp)</span></span>
<span id="cb8-234"><a href="#cb8-234" aria-hidden="true" tabindex="-1"></a><span class="in">capa_modis = QgsVectorLayer(modis_temp, 'Incendios MODIS (2000-2020)', 'ogr')</span></span>
<span id="cb8-235"><a href="#cb8-235" aria-hidden="true" tabindex="-1"></a><span class="in">QgsProject.instance().addMapLayer(capa_modis)</span></span>
<span id="cb8-236"><a href="#cb8-236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-237"><a href="#cb8-237" aria-hidden="true" tabindex="-1"></a><span class="in"># Exportar VIIRS</span></span>
<span id="cb8-238"><a href="#cb8-238" aria-hidden="true" tabindex="-1"></a><span class="in">viirs_temp = os.path.join(tempfile.gettempdir(), 'incendios_viirs.geojson')</span></span>
<span id="cb8-239"><a href="#cb8-239" aria-hidden="true" tabindex="-1"></a><span class="in">geemap.ee_to_geojson(todos_viirs_aoi, viirs_temp)</span></span>
<span id="cb8-240"><a href="#cb8-240" aria-hidden="true" tabindex="-1"></a><span class="in">capa_viirs = QgsVectorLayer(viirs_temp, 'Incendios VIIRS (2012-2021)', 'ogr')</span></span>
<span id="cb8-241"><a href="#cb8-241" aria-hidden="true" tabindex="-1"></a><span class="in">QgsProject.instance().addMapLayer(capa_viirs)</span></span>
<span id="cb8-242"><a href="#cb8-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-243"><a href="#cb8-243" aria-hidden="true" tabindex="-1"></a><span class="in">print("¡Capas agregadas al mapa!")</span></span>
<span id="cb8-244"><a href="#cb8-244" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb8-245"><a href="#cb8-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-246"><a href="#cb8-246" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Pasos para analizar (cuadrícula hexagonal)</span></span>
<span id="cb8-247"><a href="#cb8-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-248"><a href="#cb8-248" aria-hidden="true" tabindex="-1"></a>**4. Preparar datos para agregación espacial y temporal**:</span>
<span id="cb8-249"><a href="#cb8-249" aria-hidden="true" tabindex="-1"></a>Ahora necesitamos procesar los datos de incendios para poder analizarlos espacialmente. Extraemos solo la geometría y fecha de cada incendio, y los combinamos en un solo dataset. Luego agrupamos por geometría y mes para obtener observaciones únicas por mes, eliminando duplicados temporales.</span>
<span id="cb8-250"><a href="#cb8-250" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-251"><a href="#cb8-251" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb8-252"><a href="#cb8-252" aria-hidden="true" tabindex="-1"></a><span class="in"># Obtener las capas de incendios del proyecto QGIS</span></span>
<span id="cb8-253"><a href="#cb8-253" aria-hidden="true" tabindex="-1"></a><span class="in">print("Obteniendo capas de incendios...")</span></span>
<span id="cb8-254"><a href="#cb8-254" aria-hidden="true" tabindex="-1"></a><span class="in">capa_modis = QgsProject.instance().mapLayersByName('Incendios MODIS (2000-2020)')[0]</span></span>
<span id="cb8-255"><a href="#cb8-255" aria-hidden="true" tabindex="-1"></a><span class="in">capa_viirs = QgsProject.instance().mapLayersByName('Incendios VIIRS (2012-2021)')[0]</span></span>
<span id="cb8-256"><a href="#cb8-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-257"><a href="#cb8-257" aria-hidden="true" tabindex="-1"></a><span class="in"># Convertir capas QGIS a GeoDataFrames con conversión de fechas</span></span>
<span id="cb8-258"><a href="#cb8-258" aria-hidden="true" tabindex="-1"></a><span class="in">print("Convirtiendo capas a GeoDataFrames...")</span></span>
<span id="cb8-259"><a href="#cb8-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-260"><a href="#cb8-260" aria-hidden="true" tabindex="-1"></a><span class="in">def qgis_to_gdf_with_dates(layer):</span></span>
<span id="cb8-261"><a href="#cb8-261" aria-hidden="true" tabindex="-1"></a><span class="in">    """Convertir capa QGIS a GeoDataFrame con fechas correctamente formateadas"""</span></span>
<span id="cb8-262"><a href="#cb8-262" aria-hidden="true" tabindex="-1"></a><span class="in">    features = []</span></span>
<span id="cb8-263"><a href="#cb8-263" aria-hidden="true" tabindex="-1"></a><span class="in">    for f in layer.getFeatures():</span></span>
<span id="cb8-264"><a href="#cb8-264" aria-hidden="true" tabindex="-1"></a><span class="in">        attrs = dict(zip([field.name() for field in f.fields()], f.attributes()))</span></span>
<span id="cb8-265"><a href="#cb8-265" aria-hidden="true" tabindex="-1"></a><span class="in">        geom = f.geometry()</span></span>
<span id="cb8-266"><a href="#cb8-266" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb8-267"><a href="#cb8-267" aria-hidden="true" tabindex="-1"></a><span class="in">        # Convertir QDate a datetime de Python</span></span>
<span id="cb8-268"><a href="#cb8-268" aria-hidden="true" tabindex="-1"></a><span class="in">        if 'acq_date' in attrs:</span></span>
<span id="cb8-269"><a href="#cb8-269" aria-hidden="true" tabindex="-1"></a><span class="in">            qdate = attrs['acq_date']</span></span>
<span id="cb8-270"><a href="#cb8-270" aria-hidden="true" tabindex="-1"></a><span class="in">            if qdate is not None:</span></span>
<span id="cb8-271"><a href="#cb8-271" aria-hidden="true" tabindex="-1"></a><span class="in">                attrs['acq_date'] = datetime(qdate.year(), qdate.month(), qdate.day())</span></span>
<span id="cb8-272"><a href="#cb8-272" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb8-273"><a href="#cb8-273" aria-hidden="true" tabindex="-1"></a><span class="in">        attrs['geometry'] = wkt.loads(geom.asWkt())</span></span>
<span id="cb8-274"><a href="#cb8-274" aria-hidden="true" tabindex="-1"></a><span class="in">        features.append(attrs)</span></span>
<span id="cb8-275"><a href="#cb8-275" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb8-276"><a href="#cb8-276" aria-hidden="true" tabindex="-1"></a><span class="in">    gdf = gpd.GeoDataFrame(features, geometry='geometry', crs=layer.crs().authid())</span></span>
<span id="cb8-277"><a href="#cb8-277" aria-hidden="true" tabindex="-1"></a><span class="in">    return gdf</span></span>
<span id="cb8-278"><a href="#cb8-278" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-279"><a href="#cb8-279" aria-hidden="true" tabindex="-1"></a><span class="in">modis_gdf = qgis_to_gdf_with_dates(capa_modis)</span></span>
<span id="cb8-280"><a href="#cb8-280" aria-hidden="true" tabindex="-1"></a><span class="in">viirs_gdf = qgis_to_gdf_with_dates(capa_viirs)</span></span>
<span id="cb8-281"><a href="#cb8-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-282"><a href="#cb8-282" aria-hidden="true" tabindex="-1"></a><span class="in"># Reproyectar a EPSG:5347</span></span>
<span id="cb8-283"><a href="#cb8-283" aria-hidden="true" tabindex="-1"></a><span class="in">modis_gdf = modis_gdf.to_crs('EPSG:5347')</span></span>
<span id="cb8-284"><a href="#cb8-284" aria-hidden="true" tabindex="-1"></a><span class="in">viirs_gdf = viirs_gdf.to_crs('EPSG:5347')</span></span>
<span id="cb8-285"><a href="#cb8-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-286"><a href="#cb8-286" aria-hidden="true" tabindex="-1"></a><span class="in"># 1. Extraer solo geometría y fecha de ambos gdfs</span></span>
<span id="cb8-287"><a href="#cb8-287" aria-hidden="true" tabindex="-1"></a><span class="in">print("Extrayendo geometría y fecha de los datos MODIS...")</span></span>
<span id="cb8-288"><a href="#cb8-288" aria-hidden="true" tabindex="-1"></a><span class="in">modis_subset = modis_gdf[['geometry', 'acq_date']].copy()</span></span>
<span id="cb8-289"><a href="#cb8-289" aria-hidden="true" tabindex="-1"></a><span class="in">modis_subset['source'] = 'MODIS'</span></span>
<span id="cb8-290"><a href="#cb8-290" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-291"><a href="#cb8-291" aria-hidden="true" tabindex="-1"></a><span class="in">print("Extrayendo geometría y fecha de los datos VIIRS...")</span></span>
<span id="cb8-292"><a href="#cb8-292" aria-hidden="true" tabindex="-1"></a><span class="in">viirs_subset = viirs_gdf[['geometry', 'acq_date']].copy()</span></span>
<span id="cb8-293"><a href="#cb8-293" aria-hidden="true" tabindex="-1"></a><span class="in">viirs_subset['source'] = 'VIIRS'</span></span>
<span id="cb8-294"><a href="#cb8-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-295"><a href="#cb8-295" aria-hidden="true" tabindex="-1"></a><span class="in"># 2. Concatenar en un solo dataframe</span></span>
<span id="cb8-296"><a href="#cb8-296" aria-hidden="true" tabindex="-1"></a><span class="in">print("Concatenando dataframes...")</span></span>
<span id="cb8-297"><a href="#cb8-297" aria-hidden="true" tabindex="-1"></a><span class="in">combined_gdf = pd.concat([modis_subset, viirs_subset], ignore_index=True)</span></span>
<span id="cb8-298"><a href="#cb8-298" aria-hidden="true" tabindex="-1"></a><span class="in">combined_gdf = gpd.GeoDataFrame(combined_gdf, geometry='geometry', crs='EPSG:5347')</span></span>
<span id="cb8-299"><a href="#cb8-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-300"><a href="#cb8-300" aria-hidden="true" tabindex="-1"></a><span class="in"># 3. Extraer año-mes de acq_date y agrupar por geometría, año-mes</span></span>
<span id="cb8-301"><a href="#cb8-301" aria-hidden="true" tabindex="-1"></a><span class="in">print("Procesando fechas y agrupando...")</span></span>
<span id="cb8-302"><a href="#cb8-302" aria-hidden="true" tabindex="-1"></a><span class="in">combined_gdf['acq_date'] = pd.to_datetime(combined_gdf['acq_date'])</span></span>
<span id="cb8-303"><a href="#cb8-303" aria-hidden="true" tabindex="-1"></a><span class="in">combined_gdf['year_month'] = combined_gdf['acq_date'].dt.to_period('M')</span></span>
<span id="cb8-304"><a href="#cb8-304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-305"><a href="#cb8-305" aria-hidden="true" tabindex="-1"></a><span class="in"># Agrupar por geometría y año-mes para obtener observaciones únicas por mes</span></span>
<span id="cb8-306"><a href="#cb8-306" aria-hidden="true" tabindex="-1"></a><span class="in">grouped = combined_gdf.groupby(['geometry', 'year_month']).size().reset_index(name='count')</span></span>
<span id="cb8-307"><a href="#cb8-307" aria-hidden="true" tabindex="-1"></a><span class="in">grouped_gdf = gpd.GeoDataFrame(grouped, geometry='geometry', crs='EPSG:5347')</span></span>
<span id="cb8-308"><a href="#cb8-308" aria-hidden="true" tabindex="-1"></a><span class="in">print(f"Total de combinaciones únicas geometría-mes: {len(grouped_gdf)}")</span></span>
<span id="cb8-309"><a href="#cb8-309" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb8-310"><a href="#cb8-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-311"><a href="#cb8-311" aria-hidden="true" tabindex="-1"></a>**5. Crear cuadrícula hexagonal de 1km (resolución máxima de MODIS)**:</span>
<span id="cb8-312"><a href="#cb8-312" aria-hidden="true" tabindex="-1"></a>Para analizar los patrones espaciales de incendios, creamos una cuadrícula hexagonal de 1km de espaciado. Elegimos hexágonos porque proporcionan una mejor distribución espacial que cuadrados, y 1km porque es la resolución máxima de los datos MODIS. Esto significa que no podemos agregar a una escala menor sin perder precisión.</span>
<span id="cb8-313"><a href="#cb8-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-314"><a href="#cb8-314" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb8-315"><a href="#cb8-315" aria-hidden="true" tabindex="-1"></a><span class="in"># 4. Crear una cuadrícula hexagonal con 1km de espaciado usando QGIS</span></span>
<span id="cb8-316"><a href="#cb8-316" aria-hidden="true" tabindex="-1"></a><span class="in">print("Creando cuadrícula hexagonal...")</span></span>
<span id="cb8-317"><a href="#cb8-317" aria-hidden="true" tabindex="-1"></a><span class="in">aoi_layer = QgsProject.instance().mapLayersByName('AOI')[0]</span></span>
<span id="cb8-318"><a href="#cb8-318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-319"><a href="#cb8-319" aria-hidden="true" tabindex="-1"></a><span class="in">hex_result = processing.run("native:creategrid", {</span></span>
<span id="cb8-320"><a href="#cb8-320" aria-hidden="true" tabindex="-1"></a><span class="in">    'TYPE': 4,</span></span>
<span id="cb8-321"><a href="#cb8-321" aria-hidden="true" tabindex="-1"></a><span class="in">    'EXTENT': aoi_layer.extent(),</span></span>
<span id="cb8-322"><a href="#cb8-322" aria-hidden="true" tabindex="-1"></a><span class="in">    'HSPACING': 1000,</span></span>
<span id="cb8-323"><a href="#cb8-323" aria-hidden="true" tabindex="-1"></a><span class="in">    'VSPACING': 1000,</span></span>
<span id="cb8-324"><a href="#cb8-324" aria-hidden="true" tabindex="-1"></a><span class="in">    'HOVERLAY': 0,</span></span>
<span id="cb8-325"><a href="#cb8-325" aria-hidden="true" tabindex="-1"></a><span class="in">    'VOVERLAY': 0,</span></span>
<span id="cb8-326"><a href="#cb8-326" aria-hidden="true" tabindex="-1"></a><span class="in">    'CRS': aoi_layer.crs(),</span></span>
<span id="cb8-327"><a href="#cb8-327" aria-hidden="true" tabindex="-1"></a><span class="in">    'OUTPUT': 'memory:'</span></span>
<span id="cb8-328"><a href="#cb8-328" aria-hidden="true" tabindex="-1"></a><span class="in">})</span></span>
<span id="cb8-329"><a href="#cb8-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-330"><a href="#cb8-330" aria-hidden="true" tabindex="-1"></a><span class="in">hex_layer = hex_result['OUTPUT']</span></span>
<span id="cb8-331"><a href="#cb8-331" aria-hidden="true" tabindex="-1"></a><span class="in">print(f"Creados {hex_layer.featureCount()} celdas hexagonales")</span></span>
<span id="cb8-332"><a href="#cb8-332" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb8-333"><a href="#cb8-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-334"><a href="#cb8-334" aria-hidden="true" tabindex="-1"></a>**6. Unir observaciones a cuadrícula y contar**:</span>
<span id="cb8-335"><a href="#cb8-335" aria-hidden="true" tabindex="-1"></a>Finalmente, unimos nuestros puntos de incendios con la cuadrícula hexagonal usando operaciones espaciales. Contamos dos métricas importantes: el número de meses únicos con observaciones por hexágono (frecuencia temporal) y el número total de observaciones por hexágono (intensidad). Esto nos da una visión completa de los patrones de incendios en el espacio y tiempo.</span>
<span id="cb8-336"><a href="#cb8-336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-337"><a href="#cb8-337" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb8-338"><a href="#cb8-338" aria-hidden="true" tabindex="-1"></a><span class="in"># Convertir capa hexagonal a GeoDataFrame</span></span>
<span id="cb8-339"><a href="#cb8-339" aria-hidden="true" tabindex="-1"></a><span class="in">hex_features = []</span></span>
<span id="cb8-340"><a href="#cb8-340" aria-hidden="true" tabindex="-1"></a><span class="in">for f in hex_layer.getFeatures():</span></span>
<span id="cb8-341"><a href="#cb8-341" aria-hidden="true" tabindex="-1"></a><span class="in">    hex_features.append({'geometry': wkt.loads(f.geometry().asWkt())})</span></span>
<span id="cb8-342"><a href="#cb8-342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-343"><a href="#cb8-343" aria-hidden="true" tabindex="-1"></a><span class="in">hex_gdf = gpd.GeoDataFrame(hex_features, geometry='geometry', crs=hex_layer.crs().authid())</span></span>
<span id="cb8-344"><a href="#cb8-344" aria-hidden="true" tabindex="-1"></a><span class="in">hex_gdf = hex_gdf.to_crs('EPSG:5347')</span></span>
<span id="cb8-345"><a href="#cb8-345" aria-hidden="true" tabindex="-1"></a><span class="in">hex_gdf['cell_id'] = hex_gdf.index</span></span>
<span id="cb8-346"><a href="#cb8-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-347"><a href="#cb8-347" aria-hidden="true" tabindex="-1"></a><span class="in"># 5. Contar número de meses por hexágono con al menos una observación</span></span>
<span id="cb8-348"><a href="#cb8-348" aria-hidden="true" tabindex="-1"></a><span class="in">print("Contando meses por hexágono...")</span></span>
<span id="cb8-349"><a href="#cb8-349" aria-hidden="true" tabindex="-1"></a><span class="in">points_in_hex = gpd.sjoin(grouped_gdf, hex_gdf, how='left', predicate='within')</span></span>
<span id="cb8-350"><a href="#cb8-350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-351"><a href="#cb8-351" aria-hidden="true" tabindex="-1"></a><span class="in"># Contar meses únicos por hexágono</span></span>
<span id="cb8-352"><a href="#cb8-352" aria-hidden="true" tabindex="-1"></a><span class="in">months_per_hex = points_in_hex.groupby('cell_id')['year_month'].nunique().reset_index(name='meses_con_observaciones')</span></span>
<span id="cb8-353"><a href="#cb8-353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-354"><a href="#cb8-354" aria-hidden="true" tabindex="-1"></a><span class="in"># 6. Contar observaciones totales por hexágono</span></span>
<span id="cb8-355"><a href="#cb8-355" aria-hidden="true" tabindex="-1"></a><span class="in">print("Contando observaciones totales por hexágono...")</span></span>
<span id="cb8-356"><a href="#cb8-356" aria-hidden="true" tabindex="-1"></a><span class="in">total_obs_per_hex = points_in_hex.groupby('cell_id')['count'].sum().reset_index(name='observaciones_totales')</span></span>
<span id="cb8-357"><a href="#cb8-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-358"><a href="#cb8-358" aria-hidden="true" tabindex="-1"></a><span class="in"># Combinar ambas métricas en un solo GeoDataFrame</span></span>
<span id="cb8-359"><a href="#cb8-359" aria-hidden="true" tabindex="-1"></a><span class="in">hex_final = hex_gdf.merge(months_per_hex, on='cell_id', how='left')</span></span>
<span id="cb8-360"><a href="#cb8-360" aria-hidden="true" tabindex="-1"></a><span class="in">hex_final = hex_final.merge(total_obs_per_hex, on='cell_id', how='left')</span></span>
<span id="cb8-361"><a href="#cb8-361" aria-hidden="true" tabindex="-1"></a><span class="in">hex_final['meses_con_observaciones'] = hex_final['meses_con_observaciones'].fillna(0)</span></span>
<span id="cb8-362"><a href="#cb8-362" aria-hidden="true" tabindex="-1"></a><span class="in">hex_final['observaciones_totales'] = hex_final['observaciones_totales'].fillna(0)</span></span>
<span id="cb8-363"><a href="#cb8-363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-364"><a href="#cb8-364" aria-hidden="true" tabindex="-1"></a><span class="in"># Guardar como capa temporal y agregar al mapa</span></span>
<span id="cb8-365"><a href="#cb8-365" aria-hidden="true" tabindex="-1"></a><span class="in">print("Agregando cuadrícula hexagonal al mapa...")</span></span>
<span id="cb8-366"><a href="#cb8-366" aria-hidden="true" tabindex="-1"></a><span class="in">hex_temp = os.path.join(tempfile.gettempdir(), 'cuadricula_hexagonal_incendios.geojson')</span></span>
<span id="cb8-367"><a href="#cb8-367" aria-hidden="true" tabindex="-1"></a><span class="in">hex_final.to_file(hex_temp, driver='GeoJSON')</span></span>
<span id="cb8-368"><a href="#cb8-368" aria-hidden="true" tabindex="-1"></a><span class="in">hex_final_layer = QgsVectorLayer(hex_temp, 'Cuadrícula Hexagonal - Incendios', 'ogr')</span></span>
<span id="cb8-369"><a href="#cb8-369" aria-hidden="true" tabindex="-1"></a><span class="in">QgsProject.instance().addMapLayer(hex_final_layer)</span></span>
<span id="cb8-370"><a href="#cb8-370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-371"><a href="#cb8-371" aria-hidden="true" tabindex="-1"></a><span class="in">print("¡Agregación completada!")</span></span>
<span id="cb8-372"><a href="#cb8-372" aria-hidden="true" tabindex="-1"></a><span class="in">print(f"Meses máximos con observaciones en un hexágono: {hex_final['meses_con_observaciones'].max()}")</span></span>
<span id="cb8-373"><a href="#cb8-373" aria-hidden="true" tabindex="-1"></a><span class="in">print(f"Observaciones totales máximas en un hexágono: {hex_final['observaciones_totales'].max()}")</span></span>
<span id="cb8-374"><a href="#cb8-374" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb8-375"><a href="#cb8-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-376"><a href="#cb8-376" aria-hidden="true" tabindex="-1"></a><span class="fu">### Dashboard FIRMS</span></span>
<span id="cb8-377"><a href="#cb8-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-378"><a href="#cb8-378" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Explorar dashboard</span></span>
<span id="cb8-379"><a href="#cb8-379" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-380"><a href="#cb8-380" aria-hidden="true" tabindex="-1"></a><span class="fu">##### Explicar qué pueden y no pueden hacer los datos</span></span>
<span id="cb8-381"><a href="#cb8-381" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-382"><a href="#cb8-382" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Configurar alertas para AOI subiendo archivo de límites</span></span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Powered by <a href="https://quarto.org">Quarto</a></p>
</div>   
    <div class="nav-footer-center">
<p><a href="mailto:nissimlebovits@proton.me">Contact Me</a></p>
</div>
    <div class="nav-footer-right">
<p>© 2025 Nissim Lebovits</p>
</div>
  </div>
</footer>




<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>
